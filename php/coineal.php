<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\InvalidOrder;

class coineal extends Exchange {

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'id' => 'coineal',
            'name' => 'Coineal',
            'countries' => ['UK'],
            'rateLimit' => 25000,
            'timeout' => 40000,
            'has' => array(
                'fetchMarkets' => true,  // Trading Pairs and Precision
                'fetchOHLCV' => true,     // Get Market Chart Information
                'fetchOrderBook' => true,  // Get Market Depth
                'fetchTrades' => true,   // Get Market Trading Record
                'createOrder' => true,    // Create Orders
                'cancelOrder' => true,       // Cancel Limit Orders
                'fetchMyTrades' => true,     // Account Transcation Records
                'fetchOpenOrders' => true,    // Get Current Orders
                'fetchBalance' => true,    // Account Balances
            ),
            'urls' => array(
                'api' => array(
                    'public' => 'https://exchange-open-api.coineal.com',
                    'private' => 'https://exchange-open-api.coineal.com',
                ),
                'www' => 'https://exchange-open-api.coineal.com',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        // 'open/api/get_ticker',
                        'open/api/common/symbols',
                        'open/api/get_records',
                        'open/api/market_dept',
                        '/open/api/get_trades',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        '/open/api/all_trade',    // Account Transaction Records
                        '/open/api/new_order',    // Fetch Open Ordes
                        '/open/api/user/account',  // Fetch My balances
                    ),
                    'post' => array(
                        '/open/api/create_order',  // Create Order
                        '/open/api/cancel_order',  // Cancel Limit Orders
                    ),
                ),
            ),
        ));
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'][$api];
        $url .= '/' . $path;
        $query = $this->omit ($params, $this->extract_params($path));
        if ($api === 'public') {
            // Case When Public $method and has QueryParams
            if ($query) {
                $url .= '?' . $this->urlencode ($query);
            }
        }
        if ($api === 'private') {
            $content = '';
            $query['api_key'] = 'apiKEy';    // Replace Api $key with original API Key
            $sortedParams = $this->keysort ($query);  // Sort $key wise as required for sign $params
            $keys = is_array($sortedParams) ? array_keys($sortedParams) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $content .= $key . (string) $sortedParams[$key];
            }
            $signature = $content . 'secretKey';  // Replace secret Key with Original Secret Key
            $hash = $this->hash ($this->encode ($signature), 'md5');
            $query['sign'] = $hash;
            if ($method === 'GET') {
                if ($query) {
                    // Api Key need to be binded
                    $url .= '?' . $this->urlencode ($query);
                }
            }
            if ($method === 'POST') {
                $body = $this->json ($query);
                $headers = array(
                    'Content-Type' => 'application/x-www-form-urlencoded',
                );
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function update_symbol ($symbol) {
        $words = explode('/', $symbol);
        $newSymbol = implode('', $words);
        return $newSymbol;
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->publicGetOpenApiCommonSymbols (array_merge($params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => array(
        //         {
        //             "$symbol" => "btcusdt",
        //             "count_coin" => "usdt",
        //             "amount_precision" => 5,
        //             "base_coin" => "btc",
        //             "price_precision" => 2
        //         }
        //     )
        // }
        $result = array();
        $markets = $this->safe_value($response, 'data');
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $market['base_coin'];
            $quoteId = $market['count_coin'];
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $precision = array(
                'base' => $market['amount_precision'],
                'quote' => $market['price_precision'],
                'amount' => $market['amount_precision'],
                'price' => $market['price_precision'],
            );
            $active = 'true'; // Assuemed If true than only query will return $result
            $entry = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => pow(10, -$precision['amount']),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function parse_ohlcv ($ohlcv, $market = null, $timeframe = '5m', $since = null, $limit = null) {
        return [
            $ohlcv[0] * 1000,
            floatval ($ohlcv[1]),
            floatval ($ohlcv[3]),
            floatval ($ohlcv[4]),
            floatval ($ohlcv[2]),
            floatval ($ohlcv[5]),
        ];
    }

    public function fetch_ohlcv ($symbol = 'btcusdt', $timeframe = 1, $params = array (), $since = null, $limit = null) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
            'period' => $timeframe,
        );
        $response = $this->publicGetOpenApiGetRecords (array_merge($request, $params));
        // Exchange $response
        // {
        //     'code' => '0',
        //     'msg' => 'suc',
        //     'data' => array(
        //                 array(
        //                     1529387760,  //Time Stamp
        //                     7585.41,  //Opening Price
        //                     7585.41,  //Highest Price
        //                     7585.41,  //Lowest Price
        //                     7585.41,  //Closing Price
        //                     0.0       //Transaction Volume
        //                 )
        //             )
        // }
        return $this->parse_ohlcvs($response['data'], $market, $timeframe, $since, $limit);
    }

    public function fetch_order_book ($symbol = 'btcusdt', $type = 'type0', $params = array ()) {
        $this->load_markets();
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
            'type' => $type,
        );
        $response = $this->publicGetOpenApiMarketDept (array_merge($request, $params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => {
        //         "tick" => {
        //             "time" => 1529408112000,  //Refresh time of depth
        //             "asks" => //Ask orders
        //             array(
        //                 array(
        //                     "6753.31", //Price of Ask 1
        //                     0.00306    //Order Size of Ask 1
        //                 ),
        //                 array(
        //                     "6754.78", //Price of Ask 2
        //                     0.61112   //Order Size of Ask 2
        //                 )
        //                 ...
        //             ),
        //             "bids" => //Bid orders
        //             array(
        //                 array(
        //                     "6732.02",  //Price of Bid 1
        //                     0.18444     //Order Size of Bid 1
        //                 ),
        //                 array(
        //                     "6730.08", //Price of Bid 2
        //                     0.14662    //Order Size of Bid 2
        //                 )
        //                 ...
        //             )
        //         }
        return $this->parse_order_book($response['data']['tick'], $response['data']['tick']['time']);
    }

    public function parse_trade ($trade, $market = null) {
        $timestamp = $this->parse8601 ($this->safe_string($trade, 'trade_time'));
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'amount');
        $symbol = $market['symbol'];
        $cost = null;
        if ($price !== null) {
            if ($amount !== null) {
                $cost = floatval ($this->cost_to_precision($symbol, $price * $amount));
            }
        }
        $tradeId = $this->safe_string($trade, 'id');
        $side = $this->safe_string($trade, 'type');
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => $tradeId,
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        );
    }

    public function fetch_trades ($symbol = 'btcusdt', $params = array (), $since = null, $limit = null) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
        );
        $response = $this->publicGetOpenApiGetTrades (array_merge($request, $params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => array(
        //         {
        //             "amount" => 0.99583,
        //             "trade_time" => 1529408112000,
        //             "price" => 6763.9,
        //             "id" => 280101,
        //             "type" => "sell"
        //         }
        //     )
        // }
        return $this->parse_trades($response['data'], $market, $since, $limit);
    }

    public function create_order ($symbol, $type, $side, $amount, $price = null, $params = null) {
        $this->load_markets();
        $updatePrice = $price;
        if ($type === 2) {
            $updatePrice = $this->price_to_precision($symbol, $price);
        }
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'time' => $this->ymdhms ($this->milliseconds ()),
            'symbol' => strtolower($updatedSymbol),
            'side' => $side,
            'type' => $type,
            'price' => $updatePrice,
            'volume' => $amount,
            // 'sign' => ,
            // remaining Needs to be completed and API key should be binded Run time
        );
        $respose = $this->privatePostOpenApiCreateOrder (array_merge($request, $params));
        // Exchange response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => {
        //         "order_id" => 34343
        //     }
        // }
        if ($respose['msg'] !== 'suc') {
            throw new InvalidOrder($respose['msg'] . ' order was rejected by the exchange ' . $this->json ($respose));
        }
        return $respose;
    }

    public function cancel_order ($id, $symbol = 'btcusdt', $params = array ()) {
        $this->load_markets();
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
            'order_id' => $id,
            'time' => $this->ymdhms ($this->milliseconds ()),
            // 'sign' => '',
            // Sign need to be filled and API KEY
        );
        $response = $this->privatePostOpenApiCancelOrder (array_merge($request, $params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => array()
        // }
        return $response;
    }

    public function fetch_my_trades ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
            'time' => $this->ymdhms ($this->milliseconds ()),
            'page' => '',
            'pageSize' => '',
            'sign' => '',
            // Api key Need to be binded
        );
        $response = $this->privateGetOpenApiAllTrade (array_merge($request, $params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => {
        //         "count" => 22,
        //         "resultList" => array(
        //             {
        //                 "volume" => "1.000",
        //                 "side" => "BUY",
        //                 "price" => "0.10000000",
        //                 "fee" => "0.16431104",
        //                 "ctime" => 1510996571195,
        //                 "deal_price" => "0.10000000",
        //                 "id" => 306,
        //                 "type" => "买入"
        //             }
        //         )
        //     }
        // }
        return $response;
    }

    public function fetch_open_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $updatedSymbol = $this->update_symbol ($symbol);
        $request = array(
            'symbol' => strtolower($updatedSymbol),
            'time' => $this->ymdhms ($this->milliseconds ()),
            'page' => '',
            'pageSize' => '',
            'sign' => '',
            // Api key Need to be binded
        );
        $response = $this->privateGetOpenApiNewOrder (array_merge($request, $params));
        // Exchange $response
        // {
        //     "code" => "0",
        //     "msg" => "suc",
        //     "data" => {
        //         "count" => 10,
        //         "resultList" => array(
        //             {
        //                 "side" => "BUY",
        //                 "total_price" => "0.10000000",
        //                 "created_at" => 1510993841000,
        //                 "avg_price" => "0.10000000",
        //                 "countCoin" => "btc",
        //                 "source" => 1,
        //                 "type" => 1,
        //                 "side_msg" => "买入",
        //                 "volume" => "1.000",
        //                 "price" => "0.10000000",
        //                 "source_msg" => "WEB",
        //                 "status_msg" => "部分成交",
        //                 "deal_volume" => "0.50000000",
        //                 "id" => 424,
        //                 "remain_volume" => "0.00000000",
        //                 "baseCoin" => "eth",
        //                 "tradeList" => array(
        //                     array(
        //                         "volume" => "0.500",
        //                         "price" => "0.10000000",
        //                         "fee" => "0.16431104",
        //                         "ctime" => 1510996571195,
        //                         "deal_price" => "0.10000000",
        //                         "id" => 306,
        //                         "type" => "买入"
        //                     }
        //                 ),
        //                 "status" => 3
        //             ),
        //             {
        //                 "side" => "SELL",
        //                 "total_price" => "0.10000000",
        //                 "created_at" => 1510993841000,
        //                 "avg_price" => "0.10000000",
        //                 "countCoin" => "btc",
        //                 "source" => 1,
        //                 "type" => 1,
        //                 "side_msg" => "买入",
        //                 "volume" => "1.000",
        //                 "price" => "0.10000000",
        //                 "source_msg" => "WEB",
        //                 "status_msg" => "未成交",
        //                 "deal_volume" => "0.00000000",
        //                 "id" => 425,
        //                 "remain_volume" => "0.00000000",
        //                 "baseCoin" => "eth",
        //                 "tradeList" => array(),
        //                 "status" => 1
        //             }
        //         )
        //     }
        // }
        return $response;
    }
}
