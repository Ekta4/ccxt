<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception as Exception; // a common import

class kryptono extends Exchange {

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'id' => 'kryptono',
            'name' => 'Kryptono',
            'countries' => ['SG'],
            'version' => 'v2',
            'rateLimit' => 1000, // TODO => Check if this is the corrrect as per CCXT requirments. Kryptono gives 1000 minute intervals.
            'certified' => true, // TODO => Verify with Tony.
            // new metainfo interface
            'has' => array (
                'CORS' => true,
                'fetchMarkets' => true,
                'fetchCurrencies' => true,
                'fetchTradingLimits' => false,
                'fetchFundingLimits' => false,
                'fetchTickers' => true, // TODO : Check with doc for fetchTicker
                'fetchOrderBook' => true,
                'fetchTrades' => true,
                'fetchOHLCV' => true,
                'fetchBalance' => true,
                'fetchTransactions' => false,
                'withdraw' => false,
                'desposit' => false,
                'fetchDeposits' => false,
                'fetchWithdrawals' => false,
                'fetchDepositAddress' => false,
                'fetchOrder' => true, // todo /api/v2/order/details
                'fetchOrders' => true, // todo  /api/v2/order/list/completed
                'fetchOpenOrders' => true, // todo /api/v2/order/list/open
                'fetchClosedOrders' => false, // todo api/v2/order/list/completed
                'fetchMyTrades' => 'emulated', // todo /api/v2/order/list/trades
            ),
            'timeframes' => array (
                // TODO => Check if all of these intervals are supported.
                '1m' => 'oneMin',
                '5m' => 'fiveMin',
                '30m' => 'thirtyMin',
                '1h' => 'hour',
                '1d' => 'day',
            ),
            'hostname' => 'p.kryptono.exchange/k',
            'urls' => array (
                'logo' => 'https://storage.googleapis.com/kryptono-exchange/frontend/Kryptono%20Exchange.svg',
                'api' => array (
                    'market' => 'https://api.kryptono.exchange/v1',
                    'v1' => 'https://engine2.kryptono.exchange/api/v1',
                    'v2' => 'https://p.kryptono.exchange/k/api/v2',
                ),
                'test' => array (
                    'market' => 'https://api.kryptono.exchange/v1',
                    'v1' => 'https://engine-test.kryptono.exchange/api/v1',
                    'v2' => 'https://testenv1.kryptono.exchange/k/api/v2',
                ),
                'www' => 'https://p.kryptono.exchange/k/home',
                'doc' => array (
                    'https://p.kryptono.exchange/k/api',
                ),
                'fees' => array (
                    'https://kryptono.zendesk.com/hc/en-us/articles/360004347772-2-Fee-on-Kryptono-Exchange-',
                ),
            ),
            'api' => array (
                'v2' => array (
                    'get' => array (
                        'exchange-info',
                        'market-price',
                        // these endpoints require $this->apiKey . $this->secret
                        'account/balances',
                        'account/details',
                        'order/details',
                        'order/list/all',
                        'order/list/open',
                        'order/list/completed',
                        'order/list/trades',
                        'order/trade-detail',
                    ),
                ),
                'market' => array (
                    'get' => array (
                        'getmarketsummaries',
                    ),
                ),
                'v1' => array (
                    'get' => array (
                        'cs',
                        'dp',
                        'ht',
                    ),
                ),
            ),
            // todo Trading API Information in `https://kryptono.exchange/k/api#developers-guide-api-v2-for-kryptono-exchange-july-13-2018`
            'exceptions' => array (
                // 'Call to Cancel was throttled. Try again in 60 seconds.' => '\\ccxt\\DDoSProtection',
                // 'Call to GetBalances was throttled. Try again in 60 seconds.' => '\\ccxt\\DDoSProtection',
                // 'APISIGN_NOT_PROVIDED' => '\\ccxt\\AuthenticationError',
                // 'INVALID_SIGNATURE' => '\\ccxt\\AuthenticationError',
                // 'INVALID_CURRENCY' => '\\ccxt\\ExchangeError',
                // 'INVALID_PERMISSION' => '\\ccxt\\AuthenticationError',
                // 'INSUFFICIENT_FUNDS' => '\\ccxt\\InsufficientFunds',
                // 'QUANTITY_NOT_PROVIDED' => '\\ccxt\\InvalidOrder',
                // 'MIN_TRADE_REQUIREMENT_NOT_MET' => '\\ccxt\\InvalidOrder',
                // 'ORDER_NOT_OPEN' => '\\ccxt\\OrderNotFound',
                // 'INVALID_ORDER' => '\\ccxt\\InvalidOrder',
                // 'UUID_INVALID' => '\\ccxt\\OrderNotFound',
                // 'RATE_NOT_PROVIDED' => '\\ccxt\\InvalidOrder', // createLimitBuyOrder ('ETH/BTC', 1, 0)
                // 'WHITELIST_VIOLATION_IP' => '\\ccxt\\PermissionDenied',
                // 'DUST_TRADE_DISALLOWED_MIN_VALUE' => '\\ccxt\\InvalidOrder',
                // 'RESTRICTED_MARKET' => '\\ccxt\\BadSymbol',
                // 'We are down for scheduled maintenance, but we\u2019ll be back up shortly.' => '\\ccxt\\OnMaintenance', // array("success":false,"message":"We are down for scheduled maintenance, but we\u2019ll be back up shortly.","result":null,"explanation":null)
            ),
            'options' => array (
                'parseOrderStatus' => false,
                'hasAlreadyAuthenticatedSuccessfully' => false, // a workaround for APIKEY_INVALID
                'symbolSeparator' => '_',
                // With certain currencies, like
                // AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP
                // an additional tag / memo / payment id is usually required by exchanges.
                // With Bittrex some currencies imply the "base address . tag" logic.
                // The base address for depositing is stored on $this->currencies[code]
                // The base address identifies the exchange as the recipient
                // while the tag identifies the user account within the exchange
                // and the tag is retrieved with fetchDepositAddress.
                'tag' => array (
                    'NXT' => true, // NXT, BURST
                    'CRYPTO_NOTE_PAYMENTID' => true, // AEON, XMR
                    'BITSHAREX' => true, // BTS
                    'RIPPLE' => true, // XRP
                    'NEM' => true, // XEM
                    'STELLAR' => true, // XLM
                    'STEEM' => true, // SBD, GOLOS
                    // https://github.com/ccxt/ccxt/issues/4794
                    // 'LISK' => true, // LSK
                ),
                'subaccountId' => null,
                // see the implementation of fetchClosedOrdersV3 below
                'fetchClosedOrdersMethod' => 'fetch_closed_orders_v3',
                'fetchClosedOrdersFilterBySince' => true,
            ),
        ));
    }

    public function cost_to_precision ($symbol, $cost) {
        return $this->decimal_to_precision($cost, TRUNCATE, $this->markets[$symbol]['precision']['price'], DECIMAL_PLACES);
    }

    public function fee_to_precision ($symbol, $fee) {
        return $this->decimal_to_precision($fee, TRUNCATE, $this->markets[$symbol]['precision']['price'], DECIMAL_PLACES);
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->v2GetExchangeInfo ($params);
        $symbols = $this->safe_value($response, 'symbols');
        // they mislabeled $quotes to $base
        $quotes = $this->safe_value($response, 'base_currencies');
        $minQuotesMap = array();
        for ($i = 0; $i < count ($quotes); $i++) {
            $minQuotesMap[$quotes[$i]['currency_code']] = array (
                'min' => floatval ($quotes[$i]['minimum_total_order']),
            );
        }
        $base = $this->safe_value($response, 'coins');
        $minBaseMap = array();
        for ($i = 0; $i < count ($base); $i++) {
            $minBaseMap[$base[$i]['currency_code']] = array (
                'min' => floatval ($base[$i]['minimum_order_amount']),
            );
        }
        $result = array();
        for ($i = 0; $i < count ($symbols); $i++) {
            [$base, $quote] = explode($this->options['symbolSeparator'], $symbols[$i]['symbol']);
            $hasLimitMin = $this->safe_value($minBaseMap, $base);
            $limitAmountMin = 0;
            if ($hasLimitMin) {
                $limitAmountMin = $hasLimitMin['min'];
            }
            $hasPriceMin = $this->safe_value($minQuotesMap, $quote);
            $priceAmountMin = 0;
            if ($hasPriceMin) {
                $priceAmountMin = $hasPriceMin['min'];
            }
            $result[] = array (
                'id' => $symbols[$i]['symbol'],
                'symbol' => $base . '/' . $quote,
                'base' => $base,
                'baseId' => $base,
                'quote' => $quote,
                'quoteId' => $quote,
                'active' => $symbols[$i]['allow_trading'],
                'info' => $symbols[$i],
                'precision' => array (
                    'amount' => $symbols[$i]['amount_limit_decimal'],
                    'price' => $symbols[$i]['price_limit_decimal'],
                ),
                'limits' => array (
                    'amount' => array (
                        'min' => $limitAmountMin,
                        'max' => null,
                    ),
                    'price' => array (
                        'min' => $priceAmountMin,
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_balance ($params = array ()) {
        $this->load_markets();
        // $response = $this->v2GetAccountBalances ($params);
        // $result = $response->reduce (
        //     (finalResult, asset) => {
        //         finalResult[asset['currency_code']] = array (
        //             'free' => asset.available,
        //             'used' => asset.in_order,
        //             'total' => asset.total,
        //         );
        //         return finalResult;
        //     },
        //     array( 'info' => $response )
        // );
        // return $this->parse_balance($result);
    }

    public function fetch_order ($id, $symbol = null, $params = array ()) {
        $request = array (
            'order_id' => $id,
            'timestamp' => $this->milliseconds (),
        );
        $request->recvWindow = $params->recvWindow ? $params->recvWindow : 5000;
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array (
            'symbol' => $symbol,
        );
        $response = $this->v1GetDp (array_merge ($request, $params));
        //
        // {
        //     "$symbol" : "KNOW_BTC",
        //     "$limit" : 100,
        //     "asks" : array (
        //       array (
        //         "0.00001850",   // price
        //         "69.00000000"   // size
        //       )
        //     ),
        //     "bids" : array (
        //       array (
        //         "0.00001651",       // price
        //         "11186.00000000"    // size
        //       )
        //     )
        //     "time" : 1529298130192
        //   }
        //
        return $this->parse_order_book($response, $response->time);
    }

    public function parse_ticker ($ticker, $market = null) {
        //
        //     {
        //         "MarketName":"KNOW-BTC",
        //         "High":0.00001313,
        //         "Low":0.0000121,
        //         "BaseVolume":24.06681016,
        //         "Last":0.00001253,
        //         "TimeStamp":"2018-07-10T07:44:56.936Z",
        //         "Volume":1920735.0486831602,
        //         "Bid":"0.00001260",
        //         "Ask":"0.00001242",
        //         "PrevDay":0.00001253
        //       }
        //
        $timestamp = $this->parse8601 ($this->safe_string($ticker, 'TimeStamp'));
        $symbol = null;
        $marketId = $this->safe_string($ticker, 'MarketName');
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
            } else {
                $symbol = $this->parseSymbol ($marketId);
            }
        }
        if (($symbol === null) && ($market !== null)) {
            $symbol = $market['symbol'];
        }
        $previous = $this->safe_float($ticker, 'PrevDay');
        $last = $this->safe_float($ticker, 'Last');
        $change = null;
        $percentage = null;
        if ($last !== null) {
            if ($previous !== null) {
                $change = $last - $previous;
                if ($previous > 0) {
                    $percentage = ($change / $previous) * 100;
                }
            }
        }
        return array (
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($ticker, 'High'),
            'low' => $this->safe_float($ticker, 'Low'),
            'bid' => $this->safe_float($ticker, 'Bid'),
            'bidVolume' => null,
            'ask' => $this->safe_float($ticker, 'Ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $previous,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'Volume'),
            'quoteVolume' => $this->safe_float($ticker, 'BaseVolume'),
            'info' => $ticker,
        );
    }

    public function fetch_tickers ($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->marketGetGetmarketsummaries ($params);
        //
        // {
        //     "success" => "true",
        //     "message" => "",
        //     "$result" => array (
        //       array (
        //         "MarketName":"KNOW-BTC",
        //         "High":0.00001313,
        //         "Low":0.0000121,
        //         "BaseVolume":24.06681016,
        //         "Last":0.00001253,
        //         "TimeStamp":"2018-07-10T07:44:56.936Z",
        //         "Volume":1920735.0486831602,
        //         "Bid":"0.00001260",
        //         "Ask":"0.00001242",
        //         "PrevDay":0.00001253
        //       ),
        //       array (
        //         "MarketName":"KNOW-ETH",
        //         "High":0.00018348,
        //         "Low":0.00015765,
        //         "BaseVolume":244.82775523,
        //         "Last":0.00017166,
        //         "TimeStamp":"2018-07-10T07:46:47.958Z",
        //         "Volume":1426236.4862518935,
        //         "Bid":"0.00017663",
        //         "Ask":"0.00017001",
        //         "PrevDay":0.00017166,
        //       ),
        //       ...
        //     ),
        //     "volumes" => array (
        //       array (
        //         "CoinName":"BTC",
        //         "Volume":571.64749041
        //       ),
        //       {
        //         "CoinName":"KNOW",
        //         "Volume":19873172.0273
        //       }
        //     ),
        //     "t" => 1531208813959;
        //   }
        //
        $result = $this->safe_value($response, 'result');
        $tickers = array();
        for ($i = 0; $i < count ($result); $i++) {
            $ticker = $this->parse_ticker($result[$i]);
            $tickers[] = $ticker;
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array (
            'market' => $market['id'],
        );
        $response = $this->marketGetGetmarketsummaries (array_merge ($request, $params));
        //
        // {
        //     "success" => "true",
        //     "message" => "",
        //     "result" => array (
        //       array (
        //         "MarketName":"KNOW-BTC",
        //         "High":0.00001313,
        //         "Low":0.0000121,
        //         "BaseVolume":24.06681016,
        //         "Last":0.00001253,
        //         "TimeStamp":"2018-07-10T07:44:56.936Z",
        //         "Volume":1920735.0486831602,
        //         "Bid":"0.00001260",
        //         "Ask":"0.00001242",
        //         "PrevDay":0.00001253
        //       ),
        //       array (
        //         "MarketName":"KNOW-ETH",
        //         "High":0.00018348,
        //         "Low":0.00015765,
        //         "BaseVolume":244.82775523,
        //         "Last":0.00017166,
        //         "TimeStamp":"2018-07-10T07:46:47.958Z",
        //         "Volume":1426236.4862518935,
        //         "Bid":"0.00017663",
        //         "Ask":"0.00017001",
        //         "PrevDay":0.00017166,
        //       ),
        //       ...
        //     ),
        //     "volumes" => array (
        //       array (
        //         "CoinName":"BTC",
        //         "Volume":571.64749041
        //       ),
        //       {
        //         "CoinName":"KNOW",
        //         "Volume":19873172.0273
        //       }
        //     ),
        //     "t" => 1531208813959;
        //   }
        //
        $ticker = $response['result'][0];
        return $this->parse_ticker($ticker, $market);
    }

    public function fetch_trades ($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        // $market = $this->market ($symbol);
        // $request = array (
        //     'symbol' => $symbol,
        // );
        // $response = $this->v1GetHt (array_merge ($request, $params));
        //
        // {
        // "$symbol":"KNOW_BTC",
        // "$limit":100,
        // "$history":array (
        //     {
        //     "id":139638,
        //     "price":"0.00001723",
        //     "qty":"81.00000000",
        //     "isBuyerMaker":false,
        //     "time":1529262196270
        //     }
        // ),
        // "time":1529298130192
        // }
        //
        // if (is_array($response) && array_key_exists('history', $response)) {
        //     if ($response['history'] !== null) {
        //         $history = $response->history.map (item => (array( ...item, 'timestamp' => item.time )));
        //         return $this->parse_trades($history, $market, $since, $limit);
        //     }
        // }
        // throw new ExchangeError($this->id . ' fetchTrades() returned null response');
    }

    public function parse_ohlcv ($ohlcv, $market = null, $timeframe = '1d', $since = null, $limit = null) {
        $timestamp = $this->parse8601 ($ohlcv['T'] . '+00:00');
        return [
            $timestamp,
            $ohlcv['O'],
            $ohlcv['H'],
            $ohlcv['L'],
            $ohlcv['C'],
            $ohlcv['V'],
        ];
    }

    public function fetch_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        // https://engine2.kryptono.exchange/api/v1/cs?$symbol=BTC_USDT&tt=1m
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array (
            'tickInterval' => $this->timeframes[$timeframe],
            'marketName' => $market['id'],
        );
        $response = $this->v1GetCs (array_merge ($request, $params));
        if (is_array($response) && array_key_exists('result', $response)) {
            if ($response['result']) {
                return $this->parse_ohlcvs($response['result'], $market, $timeframe, $since, $limit);
            }
        }
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->implode_params($this->urls['api'][$api], array (
            'hostname' => $this->hostname,
        )) . '/';
        if ($api !== 'v2' && $api !== 'v3' && $api !== 'v3public') {
            $url .= $this->version . '/';
        }
        list($route) = explode('/', $path);
        if ($route === 'account') {
            $this->check_required_credentials();
            $url .= $path;
            $query = $this->urlencode (array_merge (array (
                'timestamp' => $this->milliseconds (),
                'recvWindow' => $this->options['recvWindow'],
            ), $params));
            $signature = $this->hmac ($this->encode ($query), $this->encode ($this->secret));
            $url .= '?' . $query;
            $headers = array (
                'Authorization' => $this->apiKey,
                'Signature' => $signature,
                'X-Requested-With' => 'XMLHttpRequest',
                'Content-Type' => 'application/json',
            );
        } else if ($route === 'order') {
            $this->check_required_credentials();
            //  todo we may be able to combine with 'account' part of if statement above if $body can be signed similarly
        } else { // public endpoints
            $url .= $path;
            if ($params) {
                $url .= '?' . $this->urlencode ($params);
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function request ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $response = $this->fetch2 ($path, $api, $method, $params, $headers, $body);
        // a workaround for APIKEY_INVALID
        if (($api === 'account') || ($api === 'market')) {
            $this->options['hasAlreadyAuthenticatedSuccessfully'] = true;
        }
        return $response;
    }
}
